import { defineComponent as G, inject as X, ref as c, computed as h, reactive as Y, watch as y, onMounted as Z, nextTick as E, onBeforeUnmount as ee, openBlock as te, createElementBlock as ae, normalizeClass as ne, normalizeStyle as oe, withModifiers as re, renderSlot as le, createCommentVNode as ue } from "vue";
const se = [
  "selection",
  "mainMenuBar",
  "navigationBar",
  "statusBar",
  "askToFormat",
  "readOnly",
  "indentation",
  "tabSize",
  "escapeControlCharacters",
  "escapeUnicodeCharacters",
  "flattenColumns",
  "validator",
  "onClassName",
  "onRenderValue",
  "onRenderMenu"
], ie = [
  "selection",
  "mode",
  "mainMenuBar",
  "navigationBar",
  "statusBar",
  "askToFormat",
  "readOnly",
  "indentation",
  "tabSize",
  "escapeControlCharacters",
  "escapeUnicodeCharacters",
  "flattenColumns",
  "validator",
  "parser",
  "validationParser",
  "pathParser",
  "onClassName",
  "onRenderValue",
  "onRenderMenu"
], de = (a = {}, u) => {
  const r = {};
  for (const n of ie) {
    const d = u[n] !== void 0 ? u[n] : a[n];
    d !== void 0 && (r[n] = d);
  }
  return r;
}, ce = `
  <svg 
    class="fa-icon svelte-1dof0an" 
    viewBox="0 0 1024 1024" 
    version="1.1"
     xmlns="http://www.w3.org/2000/svg" 
     p-id="1927" xmlns:xlink="http://www.w3.org/1999/xlink" 
     width="24" 
     height="24"
  >
    <path d="M63.989383 105.442494l0 268.396843c0 18.935258 15.368012 34.304294 34.304294 34.304294 18.936281 0 34.304294-15.369036 34.304294-34.304294L132.597971 180.156126l218.107483 218.176045c12.82919 12.830213 33.618679 12.830213 46.515407 0 12.830213-12.897751 12.830213-33.686217 0-46.51643l-218.176045-218.107483 193.683211 0c18.935258 0 34.304294-15.369036 34.304294-34.304294 0-18.935258-15.369036-34.304294-34.304294-34.304294L104.331183 65.09967C79.288834 65.09967 63.989383 77.999468 63.989383 105.442494L63.989383 105.442494z" p-id="1928" fill="#e6e6e6"></path><path d="M917.688719 65.09967 649.290853 65.09967c-18.935258 0-34.304294 15.369036-34.304294 34.304294 0 18.936281 15.369036 34.304294 34.304294 34.304294l193.683211 0-218.176045 218.107483c-12.830213 12.82919-12.830213 33.618679 0 46.51643 12.897751 12.830213 33.686217 12.830213 46.515407 0L889.420909 180.156126l0 193.683211c0 18.935258 15.369036 34.304294 34.304294 34.304294 18.936281 0 34.304294-15.369036 34.304294-34.304294L958.029496 105.442494C958.029496 77.999468 942.79963 65.09967 917.688719 65.09967L917.688719 65.09967z" p-id="1929" fill="#e6e6e6"></path>
    <path d="M104.331183 957.013353l268.397866 0c18.935258 0 34.304294-15.368012 34.304294-34.304294 0-18.936281-15.369036-34.304294-34.304294-34.304294L179.045839 888.404766l218.176045-218.107483c12.830213-12.82919 12.830213-33.618679 0-46.515407-12.897751-12.830213-33.686217-12.830213-46.515407 0l-218.107483 218.176045L132.598994 648.27471c0-18.935258-15.368012-34.304294-34.304294-34.304294-18.936281 0-34.304294 15.369036-34.304294 34.304294l0 268.397866C63.989383 944.115602 79.288834 957.013353 104.331183 957.013353L104.331183 957.013353z" p-id="1930" fill="#e6e6e6"></path>
    <path d="M958.029496 916.671553 958.029496 648.27471c0-18.935258-15.368012-34.304294-34.304294-34.304294-18.935258 0-34.304294 15.369036-34.304294 34.304294l0 193.683211L671.313425 623.781876c-12.82919-12.830213-33.618679-12.830213-46.515407 0-12.830213 12.897751-12.830213 33.686217 0 46.515407l218.176045 218.107483L649.290853 888.404766c-18.935258 0-34.304294 15.368012-34.304294 34.304294 0 18.936281 15.369036 34.304294 34.304294 34.304294l268.397866 0C942.79963 957.013353 958.029496 944.115602 958.029496 916.671553L958.029496 916.671553z" p-id="1931" fill="#e6e6e6"></path>
  </svg>
`, T = (a, u, r = !1) => {
  const n = a && typeof a[u] < "u";
  return !n && r && console.warn("Typeguard warn!!! The object has no property: ", u), n;
}, fe = G({
  name: "JsonEditor",
  props: {
    /**
     * ### modelValue: unknown
     * Pass the JSON value or string to be rendered in the JSONEditor.
     * */
    modelValue: [Object, Array, Number, String, Boolean, String, null],
    /**
     * ### value: unknown
     * props value is an alternative to modelValue
     * Pass the JSON value or string to be rendered in the JSONEditor.
     * */
    value: [Object, Array, Number, String, Boolean, String, null],
    /**
     * ### json: unknown
     * Pass the JSON value to be rendered in the JSONEditor.
     * */
    json: [Object, Array, Number, String, Boolean, null],
    /**
     * ### text: string
     * Pass the JSON string to be rendered in the JSONEditor.
     * */
    text: String,
    /**
     * ### jsonString: string
     * Same as prop 'text'. Pass the JSON string to be rendered in the JSONEditor.
     * */
    jsonString: String,
    /**
     * ### selection: JSONEditorSelection | null.
     * The current selected contents. You can use two-way binding using bind:selection. The tree mode
     * supports MultiSelection, KeySelection, ValueSelection, InsideSelection, or AfterSelection. The
     * table mode supports ValueSelection, and text mode supports TextSelection.
     * */
    selection: {
      type: Object,
      default: null
    },
    /**
     * ### mode: 'tree' | 'text' | 'table'.
     * Open the editor in 'tree' mode (default) or 'text' mode (formerly: code mode).
     * */
    mode: {
      type: String,
      default: "tree",
      validator: (a) => ["tree", "text", "table"].includes(a)
    },
    /**
     * ### mainMenuBar: boolean
     * Show the main menu bar. Default value is true.
     * */
    mainMenuBar: {
      type: Boolean,
      default: void 0
    },
    /**
     * ### navigationBar: boolean
     * Show the navigation bar with, where you can see the selected path and navigate through your
     * document from there. Default value is true.
     * */
    navigationBar: {
      type: Boolean,
      default: void 0
    },
    /**
     * ### statusBar: boolean
     * Show a status bar at the bottom of the 'text' editor, showing information about the cursor
     * location and selected contents. Default value is true.
     * */
    statusBar: {
      type: Boolean,
      default: void 0
    },
    /**
     * ### askToFormat: boolean
     * When true (default), the user will be asked whether he/she wants to format the JSON document
     * when a compact document is loaded or pasted in 'text' mode. Only applicable to 'text' mode.
     */
    askToFormat: {
      type: Boolean,
      default: void 0
    },
    /**
     * ### readOnly: boolean
     * Open the editor in read-only mode: no changes can be made, non-relevant buttons are hidden
     * from the menu, and the context menu is not enabled. Default value is false.
     * */
    readOnly: {
      type: Boolean,
      default: void 0
    },
    /**
     * ### indentation: number | string
     * Number of spaces use for indentation when stringifying JSON, or a string to be used as indentation
     * like '\t' to use a tab as indentation, or ' ' to use 4 spaces (which is equivalent to configuring
     * indentation: 4). See also property tabSize.
     * */
    indentation: [String, Number],
    /**
     * ### tabSize: number
     * When indentation is configured as a tab character (indentation: '\t'), tabSize configures how
     * large a tab character is rendered. Default value is 4. Only applicable to text mode.
     * */
    tabSize: Number,
    /**
     * ### escapeControlCharacters: boolean.
     * False by default. When true, control characters like newline and tab are rendered as escaped
     * characters \n and \t. Only applicable for 'tree' mode, in 'text' mode control characters are
     * always escaped.
     * */
    escapeControlCharacters: {
      type: Boolean,
      default: void 0
    },
    /**
     * ### escapeUnicodeCharacters: boolean.
     * False by default. When true, unicode characters like â˜Ž and ðŸ˜€ are rendered escaped
     * like \u260e and \ud83d\ude00.
     * */
    escapeUnicodeCharacters: {
      type: Boolean,
      default: void 0
    },
    /**
     * ### flattenColumns: boolean.
     * True by default. Only applicable to 'table' mode. When true, nested object properties
     * will be displayed each in their own column, with the nested path as column name. When false,
     * nested objects will be rendered inline, and double-clicking them will open them in a popup
     * */
    flattenColumns: {
      type: Boolean,
      default: void 0
    },
    /**
     * ### validator: function (json: unknown): ValidationError[].
     * Validate the JSON document. For example use the built-in JSON Schema validator
     * powered by Ajv:
     * ```ts
     *  import { createAjvValidator } from 'svelte-jsoneditor'
     *  const validator = createAjvValidator(schema, schemaDefinitions)
     * ```
     * */
    validator: Function,
    /**
     * ### parser: JSON = JSON
     * Configure a custom JSON parser, like lossless-json. By default, the native JSON
     * parser of JavaScript is used. The JSON interface is an object with a parse and
     * stringify function.
     * */
    parser: Object,
    /**
     * ### validationParser: JSONParser = JSON
     * Only applicable when a validator is provided. This is the same as parser, except
     * that this parser is used to parse the data before sending it to the validator.
     * Configure a custom JSON parser that is used to parse JSON before passing it to the
     * validator. By default, the built-in JSON parser is used. When passing a custom
     * validationParser, make sure the output of the parser is supported by the configured
     * validator. So, when the validationParser can output bigint numbers or other numeric
     * types, the validator must also support that. In tree mode, when parser is not equal
     * to validationParser, the JSON document will be converted before it is passed to the
     * validator via validationParser.parse(parser.stringify(json))
     * */
    validationParser: Object,
    /**
     * ### pathParser: JSONPathParser
     * An optional object with a parse and stringify method to parse and stringify a JSONPath,
     * which is an array with property names. The pathParser is used in the path editor in the
     * navigation bar, which is opened by clicking the edit button on the right side of the
     * navigation bar. The pathParser.parse function is allowed to throw an Error when the input
     * is invalid. By default, a JSON Path notation is used, which looks like $.data[2].nested.property.
     * Alternatively, it is possible to use for example a JSON Pointer notation
     * like /data/2/nested/property or something custom-made. Related helper functions:
     * parseJSONPath and stringifyJSONPath, parseJSONPointer and compileJSONPointer
     * */
    pathParser: Object,
    /**
     * ### queryLanguagesIds: QueryLanguageId[].
     * Configure one or multiple query language that can be used in the Transform modal.
     * An array of available query languages id's
     * [javascript', 'lodash', 'jmespath']
     * */
    queryLanguagesIds: Array,
    /**
     * ### queryLanguageId: string.
     * The id of the currently selected query language.
     * 'javascript' | 'lodash' | 'jmespath'
     * */
    queryLanguageId: String,
    /**
     * ### onClassName(path: Path, value: any): string | undefined.
     * Add a custom class name to specific nodes, based on their path and/or value.
     * */
    onClassName: Function,
    /**
     * ### onRenderValue(props: RenderValueProps) : RenderValueComponentDescription[]
     *
     * ## EXPERIMENTAL! This API will most likely change in future versions.
     * Customize rendering of the values. By default, renderValue is used, which renders a value as an
     * editable div and depending on the value can also render a boolean toggle, a color picker, and a
     * timestamp tag. Multiple components can be rendered alongside each other, like the boolean toggle
     * and color picker being rendered left from the editable div. Built in value renderer components:
     *
     *  > EditableValue, ReadonlyValue, BooleanToggle, ColorPicker, TimestampTag, EnumValue.
     *
     *
     * ```ts
     *  import { renderJSONSchemaEnum, renderValue } from 'svelte-jsoneditor'
     *
     *  function onRenderValue(props) {
     *    // use the enum renderer, and fallback on the default renderer
     *    return renderJSONSchemaEnum(props, schema, schemaDefinitions) || renderValue(props)
     *  }
     * ```
     * */
    onRenderValue: Function,
    /**
     * ### onRenderMenu(items: MenuItem[], context: { mode: 'tree' | 'text' | 'table', modal: boolean }) : MenuItem[] | undefined.
     * Callback which can be used to make changes to the menu items. New items can be added, or existing items can be removed or
     * reorganized. When the function returns undefined, the original items will be applied. Using the context values mode and
     * modal, different actions can be taken depending on the mode of the editor and whether the editor is rendered inside a
     * modal or not.
     *
     *  A menu item MenuItem can be one of the following types:
     *
     *  - Button:
     *  ```ts
     *  interface MenuButtonItem {
     *    onClick: () => void
     *    icon?: FontAwesomeIcon
     *    text?: string
     *    title?: string
     *    className?: string
     *    disabled?: boolean
     *  }
     *  ```
     *
     *  - Separator (gray vertical line between a group of items):
     *  ```ts
     *    interface MenuSeparatorItem {
     *      separator: true
     *    }
     *  ```
     *
     *  - Space (fills up empty space):
     *  ```ts
     *    interface MenuSpaceItem {
     *      space: true
     *    }
     *  ```
     * */
    onRenderMenu: Function,
    /**
     * ### height: string | number
     * Height of render container
     * */
    height: [String, Number],
    /**
     * ### fullWidthButton: boolean
     * Show full screen button
     * */
    fullWidthButton: {
      type: Boolean,
      default: void 0
    },
    /**
     * ### darkTheme: boolean
     * Switch to dark theme
     * */
    darkTheme: {
      type: Boolean,
      default: void 0
    }
  },
  emits: [
    "update:modelValue",
    "update:json",
    "update:text",
    "update:jsonString",
    "update:selection",
    "change",
    "error",
    "change-mode",
    "update:mode",
    "change-query-language",
    "focus",
    "blur"
  ],
  setup(a, { expose: u, emit: r }) {
    const n = X("jsonEditorOptions", {}), d = c(), s = c(null), f = c(!1), m = c(!1), p = c(!1), v = c("tree"), o = c(null), F = h(() => {
      const e = a.height || (n == null ? void 0 : n.height);
      return e && !f.value ? {
        height: e + "px"
      } : {};
    }), B = h(() => a.darkTheme || (n == null ? void 0 : n.darkTheme)), w = h(() => a.queryLanguagesIds || (n == null ? void 0 : n.queryLanguagesIds)), M = h(() => a.queryLanguageId || (n == null ? void 0 : n.queryLanguageId)), g = Y({}), N = async () => {
      var t;
      if (typeof window > "u" || typeof w.value > "u" || !((t = w.value) != null && t.length))
        return;
      for (const i of w.value)
        if (!g[i])
          switch (i) {
            case "javascript": {
              const { javascriptQueryLanguage: l } = await import("./vanilla-jsoneditor-JVurKMvU.js");
              g[i] = l;
              break;
            }
            case "lodash": {
              const { lodashQueryLanguage: l } = await import("./vanilla-jsoneditor-JVurKMvU.js");
              g[i] = l;
              break;
            }
            case "jmespath": {
              const { jmespathQueryLanguage: l } = await import("./vanilla-jsoneditor-JVurKMvU.js");
              g[i] = l;
              break;
            }
          }
      const e = Object.values(g);
      if (e.length !== 0)
        return e;
    }, L = () => {
      s.value && (s.value.removeEventListener("click", C), s.value = null);
    }, V = async () => {
      if (typeof window > "u")
        return;
      const { getElement: e, createElement: t } = await import("./full-width-button-handler-wnoSIg42.js"), { setFullWidthButtonStyle: i } = await import("./styles-handler-G8NSk43t.js");
      await i();
      const l = e(".jse-full-width"), _ = (n == null ? void 0 : n.fullWidthButton) !== void 0 ? n == null ? void 0 : n.fullWidthButton : !0;
      if (!(a.fullWidthButton !== void 0 ? a.fullWidthButton : _) || l)
        return;
      s.value && L();
      const $ = e(".jse-menu"), D = [...$.classList].find((K) => K.startsWith("svelte-"));
      s.value = t("button"), s.value.classList.add("jse-full-width"), s.value.classList.add("jse-button"), s.value.classList.add(D), s.value.innerHTML += ce, $.appendChild(s.value), s.value.addEventListener("click", C);
    }, C = () => {
      var e, t;
      f.value = !f.value, f.value ? (e = s.value) == null || e.classList.add("jse-full-width--active") : (t = s.value) == null || t.classList.remove("jse-full-width--active");
    }, b = async (e) => {
      var t;
      v.value === "tree" && await ((t = o.value) == null ? void 0 : t.expand(() => e));
    }, W = (e, t, i) => {
      if (p.value) {
        p.value = !1;
        return;
      }
      m.value = !0, T(e, "json") && (r("update:json", e.json), r("update:modelValue", e.json)), T(e, "text") && (r("update:text", e.text), r("update:jsonString", e.text), r("update:modelValue", e.text)), r("change", e, t, i);
    }, q = (e) => {
      r("error", e);
    }, A = (e) => {
      v.value = e, r("change-mode", e), r("update:mode", e);
    }, I = (e) => {
      r("change-query-language", e);
    }, R = () => {
      r("focus");
    }, z = () => {
      r("blur");
    }, J = (e) => {
      r("update:selection", e);
    }, Q = (e, t) => (E(() => {
      V();
    }), typeof a.onRenderMenu == "function" ? a.onRenderMenu(e, t) : e), j = async () => {
      const e = { fullWidthButton: !0, ...n || {} }, t = await N();
      return {
        ...de(e, a),
        queryLanguages: t,
        queryLanguageId: M.value,
        onChange: W,
        onError: q,
        onChangeMode: A,
        onChangeQueryLanguage: I,
        onFocus: R,
        onBlur: z,
        onRenderMenu: Q,
        onSelect: J
      };
    }, S = c(!0), k = () => {
      const e = (l = {}) => l === null || typeof l > "u" || typeof l == "number" || typeof l == "bigint" || typeof l == "string" || typeof l == "boolean" ? {
        json: l
      } : Array.isArray(l) ? {
        json: [...l]
      } : {
        json: { ...l }
      }, t = (l = "") => ({
        text: l || ""
      }), i = a.modelValue || a.value;
      return i ? v.value === "text" ? t(i) : e(i) : a.json ? e(a.json) : a.text ? t(a.text) : a.jsonString ? t(a.jsonString) : t();
    }, O = async () => {
      if (!(typeof window > "u")) {
        if (!o.value) {
          const e = await j(), { JSONEditor: t } = await import("./vanilla-jsoneditor-JVurKMvU.js");
          S.value = !1, o.value = new t({
            target: d.value,
            props: e
          }), await o.value.set(k());
        }
        await o.value.focus();
      }
    }, x = async () => {
      const e = await j();
      o.value.updateProps(e);
    }, U = () => {
      if (m.value) {
        m.value = !1;
        return;
      }
      p.value = !0, o.value.update(k());
    }, H = () => {
      o.value && (o.value.destroy(), o.value = null), L();
    };
    return y(
      [
        ...se.map((e) => () => a[e])
      ],
      x,
      { deep: !0 }
    ), y(
      [() => a.modelValue, () => a.value, () => a.json, () => a.text, () => a.jsonString],
      U,
      {
        deep: !0
      }
    ), y(
      () => a.mode,
      (e) => {
        e !== v.value && (v.value = e, x());
      }
    ), y(
      () => B.value,
      async (e) => {
        if (e) {
          const { setDarkThemeStyle: t } = await import("./styles-handler-G8NSk43t.js");
          await t();
        }
      },
      { immediate: !0 }
    ), Z(() => {
      E(() => {
        O();
      });
    }), ee(() => {
      H();
    }), u({
      async $collapseAll() {
        await b(!1);
      },
      async $expandAll() {
        await b(!0);
      },
      async $expand(e) {
        var t;
        await ((t = o.value) == null ? void 0 : t.expand(e));
      },
      $get() {
        var e;
        return (e = o.value) == null ? void 0 : e.get();
      },
      async $set(e) {
        var t;
        await ((t = o.value) == null ? void 0 : t.set(e));
      },
      async $update(e) {
        var t;
        await ((t = o.value) == null ? void 0 : t.update(e));
      },
      async $updateProps(e) {
        var t;
        await ((t = o.value) == null ? void 0 : t.updateProps(e));
      },
      async $refresh() {
        var e;
        await ((e = o.value) == null ? void 0 : e.refresh());
      },
      async $focus() {
        var e;
        await ((e = o.value) == null ? void 0 : e.focus());
      },
      async $destroy() {
        var e;
        await ((e = o.value) == null ? void 0 : e.destroy());
      },
      async $patch(e) {
        var t;
        return await ((t = o.value) == null ? void 0 : t.patch(e));
      },
      $transform(e) {
        var t;
        (t = o.value) == null || t.transform(e);
      },
      async $scrollTo(e) {
        var t;
        await ((t = o.value) == null ? void 0 : t.scrollTo(e));
      },
      $findElement(e) {
        var t;
        return (t = o.value) == null ? void 0 : t.findElement(e);
      },
      async $acceptAutoRepair() {
        var e;
        return await ((e = o.value) == null ? void 0 : e.acceptAutoRepair());
      },
      $validate() {
        var e;
        return (e = o.value) == null ? void 0 : e.validate();
      }
    }), {
      max: f,
      getHeight: F,
      container: d,
      darkThemeStyle: B,
      fallbackSlot: S
    };
  }
}), ve = (a, u) => {
  const r = a.__vccOpts || a;
  for (const [n, d] of u)
    r[n] = d;
  return r;
};
function ge(a, u, r, n, d, s) {
  return te(), ae("div", {
    class: ne(["vue-ts-json-editor", { "vue-ts-json-editor--max-box": a.max, "jse-theme-dark": a.darkThemeStyle }]),
    style: oe(a.getHeight),
    ref: "container",
    onKeydown: u[0] || (u[0] = re(() => {
    }, ["stop"]))
  }, [
    a.fallbackSlot ? le(a.$slots, "default", { key: 0 }) : ue("", !0)
  ], 38);
}
const P = /* @__PURE__ */ ve(fe, [["render", ge]]), me = {
  ...P,
  install: (a, u = {}) => {
    a.component(u.componentName || "JsonEditor", P), a.provide("jsonEditorOptions", u.options);
  }
};
export {
  me as default
};
