{"version":3,"file":"core.js","names":["_InputBuffer","require","_OutputBuffer","_JSONRepairError","_stack","_stringUtils","controlCharacters","escapeCharacters","b","f","n","r","t","jsonrepairCore","_ref","onData","bufferSize","chunkSize","input","createInputBuffer","output","createOutputBuffer","write","i","iFlushed","stack","createStack","flushInputBuffer","flush","transform","chunk","push","currentLength","parse","close","parseWhitespaceAndSkipComments","type","StackType","object","caret","Caret","beforeKey","parseObjectKey","parseUnexpectedColon","parseRepairTrailingComma","parseRepairObjectEndOrComma","beforeValue","parseValue","parseRepairMissingObjectValue","afterValue","parseObjectComma","parseObjectEnd","array","parseRepairArrayEnd","parseArrayComma","parseArrayEnd","parseRepairMissingComma","ndJson","parseRepairNdJsonEnd","functionCall","parseFunctionCallEnd","root","parseUnexpectedEnd","parseRootEnd","parseObjectStart","parseArrayStart","parseString","parseNumber","parseKeywords","parseRepairUnquotedString","parseCharacter","codeOpeningBrace","codeClosingBrace","update","codeOpeningBracket","codeClosingBracket","unquotedStringEnd","findNextDelimiter","symbol","substring","skipCharacter","codeOpenParenthesis","JSON","stringify","charCodeAt","codeDoubleQuote","endsWithIgnoringWhitespace","stripLastOccurrence","codeColon","throwObjectKeyExpected","isEnd","throwUnexpectedEnd","throwUnexpectedCharacter","parsedKey","parseUnquotedKey","truncatedText","isStartOfValue","charAt","insertBeforeLastWhitespace","throwColonExpected","codeComma","pop","codeCloseParenthesis","codeSemicolon","parsedComma","unshift","start","changed","parseWhitespace","parseComment","whitespace","normal","isWhitespace","isSpecialWhitespace","length","codeSlash","codeAsterisk","atEndOfBlockComment","codeNewline","code","skipEscapeCharacter","codeBackslash","stopAtDelimiter","arguments","undefined","iBefore","oBefore","skipEscapeChars","isQuote","isEndQuote","isDoubleQuote","isSingleQuote","isSingleQuoteLike","isDoubleQuoteLike","isEndOfString","isDelimiter","char","escapeChar","j","isHex","throwInvalidUnicodeCharacter","isControlCharacter","isValidStringCharacter","throwInvalidCharacter","hasEndQuote","isAtEnd","nextIsDelimiter","remove","parseConcatenatedString","parsed","codePlus","parsedStr","codeMinus","expectDigitOrRepair","isDigit","codeDot","codeLowercaseE","codeUppercaseE","num","hasInvalidLeadingZero","test","concat","parseKeyword","name","value","end","expectDigit","numSoFar","JSONRepairError","got","chars"],"sources":["../../../src/streaming/core.ts"],"sourcesContent":["import { createInputBuffer } from './buffer/InputBuffer.js'\nimport { createOutputBuffer } from './buffer/OutputBuffer.js'\nimport { JSONRepairError } from '../utils/JSONRepairError.js'\nimport { Caret, createStack, StackType } from './stack.js'\nimport {\n  codeAsterisk,\n  codeBackslash,\n  codeCloseParenthesis,\n  codeClosingBrace,\n  codeClosingBracket,\n  codeColon,\n  codeComma,\n  codeDot,\n  codeDoubleQuote,\n  codeLowercaseE,\n  codeMinus,\n  codeNewline,\n  codeOpeningBrace,\n  codeOpeningBracket,\n  codeOpenParenthesis,\n  codePlus,\n  codeSemicolon,\n  codeSlash,\n  codeUppercaseE,\n  isControlCharacter,\n  isDelimiter,\n  isDigit,\n  isDoubleQuote,\n  isDoubleQuoteLike,\n  isHex,\n  isQuote,\n  isSingleQuote,\n  isSingleQuoteLike,\n  isSpecialWhitespace,\n  isStartOfValue,\n  isValidStringCharacter,\n  isWhitespace\n} from '../utils/stringUtils.js'\n\nconst controlCharacters: { [key: string]: string } = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n}\n\n// map with all escape characters\nconst escapeCharacters: { [key: string]: string } = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n}\n\nexport interface JsonRepairCoreOptions {\n  onData: (chunk: string) => void\n  chunkSize?: number\n  bufferSize?: number\n}\n\nexport interface JsonRepairCore {\n  transform: (chunk: string) => void\n  flush: () => void\n}\n\nexport function jsonrepairCore({\n  onData,\n  bufferSize = 65536,\n  chunkSize = 65536\n}: JsonRepairCoreOptions): JsonRepairCore {\n  const input = createInputBuffer()\n\n  const output = createOutputBuffer({\n    write: onData,\n    bufferSize,\n    chunkSize\n  })\n\n  let i = 0\n  let iFlushed = 0\n  const stack = createStack()\n\n  function flushInputBuffer() {\n    while (iFlushed < i - bufferSize - chunkSize) {\n      iFlushed += chunkSize\n      input.flush(iFlushed)\n    }\n  }\n\n  function transform(chunk: string) {\n    input.push(chunk)\n\n    while (i < input.currentLength() - bufferSize && parse()) {\n      // loop until there is nothing more to process\n    }\n\n    flushInputBuffer()\n  }\n\n  function flush() {\n    input.close()\n\n    while (parse()) {\n      // loop until there is nothing more to process\n    }\n\n    output.flush()\n  }\n\n  function parse(): boolean {\n    parseWhitespaceAndSkipComments()\n\n    switch (stack.type) {\n      case StackType.object: {\n        switch (stack.caret) {\n          case Caret.beforeKey:\n            return (\n              parseObjectKey() ||\n              parseUnexpectedColon() ||\n              parseRepairTrailingComma() ||\n              parseRepairObjectEndOrComma()\n            )\n          case Caret.beforeValue:\n            return parseValue() || parseRepairMissingObjectValue()\n          case Caret.afterValue:\n            return parseObjectComma() || parseObjectEnd() || parseRepairObjectEndOrComma()\n          default:\n            return false\n        }\n      }\n\n      case StackType.array: {\n        switch (stack.caret) {\n          case Caret.beforeValue:\n            return parseValue() || parseRepairTrailingComma() || parseRepairArrayEnd()\n          case Caret.afterValue:\n            return (\n              parseArrayComma() ||\n              parseArrayEnd() ||\n              parseRepairMissingComma() ||\n              parseRepairArrayEnd()\n            )\n          default:\n            return false\n        }\n      }\n\n      case StackType.ndJson: {\n        switch (stack.caret) {\n          case Caret.beforeValue:\n            return parseValue() || parseRepairTrailingComma()\n          case Caret.afterValue:\n            return parseArrayComma() || parseRepairMissingComma() || parseRepairNdJsonEnd()\n          default:\n            return false\n        }\n      }\n\n      case StackType.functionCall: {\n        switch (stack.caret) {\n          case Caret.beforeValue:\n            return parseValue()\n          case Caret.afterValue:\n            return parseFunctionCallEnd()\n          default:\n            return false\n        }\n      }\n\n      case StackType.root: {\n        switch (stack.caret) {\n          case Caret.beforeValue:\n            return parseValue() || parseUnexpectedEnd()\n          case Caret.afterValue:\n            return parseRootEnd()\n          default:\n            return false\n        }\n      }\n\n      default:\n        return false\n    }\n  }\n\n  function parseValue(): boolean {\n    return (\n      parseObjectStart() ||\n      parseArrayStart() ||\n      parseString() ||\n      parseNumber() ||\n      parseKeywords() ||\n      parseRepairUnquotedString()\n    )\n  }\n\n  function parseObjectStart(): boolean {\n    if (parseCharacter(codeOpeningBrace)) {\n      parseWhitespaceAndSkipComments()\n      if (parseCharacter(codeClosingBrace)) {\n        return stack.update(Caret.afterValue)\n      }\n\n      return stack.push(StackType.object, Caret.beforeKey)\n    }\n\n    return false\n  }\n\n  function parseArrayStart(): boolean {\n    if (parseCharacter(codeOpeningBracket)) {\n      parseWhitespaceAndSkipComments()\n      if (parseCharacter(codeClosingBracket)) {\n        return stack.update(Caret.afterValue)\n      }\n\n      return stack.push(StackType.array, Caret.beforeValue)\n    }\n\n    return false\n  }\n\n  function parseRepairUnquotedString(): boolean {\n    const unquotedStringEnd = findNextDelimiter()\n    if (unquotedStringEnd !== null) {\n      const symbol = input.substring(i, unquotedStringEnd)\n      i = unquotedStringEnd\n\n      if (skipCharacter(codeOpenParenthesis)) {\n        // A MongoDB function call like NumberLong(\"2\")\n        // Or a JSONP function call like callback({...});\n        // we strip the function call\n\n        return stack.push(StackType.functionCall, Caret.beforeValue)\n      }\n\n      output.push(symbol === 'undefined' ? 'null' : JSON.stringify(symbol))\n\n      if (input.charCodeAt(i) === codeDoubleQuote) {\n        // we had a missing start quote, but now we encountered the end quote, so we can skip that one\n        i++\n      }\n\n      return stack.update(Caret.afterValue)\n    }\n\n    return false\n  }\n\n  function parseRepairMissingObjectValue(): boolean {\n    // repair missing object value\n    output.push('null')\n    return stack.update(Caret.afterValue)\n  }\n\n  function parseRepairTrailingComma(): boolean {\n    // repair trailing comma\n    if (output.endsWithIgnoringWhitespace(',')) {\n      output.stripLastOccurrence(',')\n      return stack.update(Caret.afterValue)\n    }\n\n    return false\n  }\n\n  function parseUnexpectedColon(): boolean {\n    if (input.charCodeAt(i) === codeColon) {\n      throwObjectKeyExpected()\n    }\n\n    return false\n  }\n\n  function parseUnexpectedEnd(): boolean {\n    if (input.isEnd(i)) {\n      throwUnexpectedEnd()\n    } else {\n      throwUnexpectedCharacter()\n    }\n\n    return false\n  }\n\n  function parseObjectKey(): boolean {\n    const parsedKey = parseString() || parseUnquotedKey()\n    if (parsedKey) {\n      parseWhitespaceAndSkipComments()\n\n      if (parseCharacter(codeColon)) {\n        // expect a value after the :\n        return stack.update(Caret.beforeValue)\n      }\n\n      const truncatedText = input.isEnd(i)\n      if (isStartOfValue(input.charAt(i)) || truncatedText) {\n        // repair missing colon\n        output.insertBeforeLastWhitespace(':')\n        return stack.update(Caret.beforeValue)\n      }\n\n      throwColonExpected()\n    }\n\n    return false\n  }\n\n  function parseObjectComma(): boolean {\n    if (parseCharacter(codeComma)) {\n      return stack.update(Caret.beforeKey)\n    }\n\n    return false\n  }\n\n  function parseObjectEnd(): boolean {\n    if (parseCharacter(codeClosingBrace)) {\n      return stack.pop()\n    }\n\n    return false\n  }\n\n  function parseRepairObjectEndOrComma(): true {\n    // repair missing object end and trailing comma\n    if (input.charAt(i) === '{') {\n      output.stripLastOccurrence(',')\n      output.insertBeforeLastWhitespace('}')\n      return stack.pop()\n    }\n\n    // repair missing comma\n    if (!input.isEnd(i) && isStartOfValue(input.charAt(i))) {\n      output.insertBeforeLastWhitespace(',')\n      return stack.update(Caret.beforeKey)\n    }\n\n    // repair missing closing brace\n    output.insertBeforeLastWhitespace('}')\n    return stack.pop()\n  }\n\n  function parseArrayComma(): boolean {\n    if (parseCharacter(codeComma)) {\n      return stack.update(Caret.beforeValue)\n    }\n\n    return false\n  }\n\n  function parseArrayEnd(): boolean {\n    if (parseCharacter(codeClosingBracket)) {\n      return stack.pop()\n    }\n\n    return false\n  }\n\n  function parseRepairMissingComma(): boolean {\n    // repair missing comma\n    if (!input.isEnd(i) && isStartOfValue(input.charAt(i))) {\n      output.insertBeforeLastWhitespace(',')\n      return stack.update(Caret.beforeValue)\n    }\n\n    return false\n  }\n\n  function parseRepairArrayEnd(): true {\n    // repair missing closing bracket\n    output.insertBeforeLastWhitespace(']')\n    return stack.pop()\n  }\n\n  function parseRepairNdJsonEnd(): boolean {\n    if (input.isEnd(i)) {\n      output.push('\\n]')\n      return stack.pop()\n    } else {\n      throwUnexpectedEnd()\n      return false // just to make TS happy\n    }\n  }\n\n  function parseFunctionCallEnd(): true {\n    if (skipCharacter(codeCloseParenthesis)) {\n      skipCharacter(codeSemicolon)\n    }\n\n    return stack.pop()\n  }\n\n  function parseRootEnd(): boolean {\n    const parsedComma = parseCharacter(codeComma)\n    parseWhitespaceAndSkipComments()\n\n    if (\n      isStartOfValue(input.charAt(i)) &&\n      (output.endsWithIgnoringWhitespace(',') || output.endsWithIgnoringWhitespace('\\n'))\n    ) {\n      // start of a new value after end of the root level object: looks like\n      // newline delimited JSON -> turn into a root level array\n      if (!parsedComma) {\n        // repair missing comma\n        output.insertBeforeLastWhitespace(',')\n      }\n\n      output.unshift('[\\n')\n\n      return stack.push(StackType.ndJson, Caret.beforeValue)\n    }\n\n    if (parsedComma) {\n      // repair: remove trailing comma\n      output.stripLastOccurrence(',')\n\n      return stack.update(Caret.afterValue)\n    }\n\n    // repair redundant end braces and brackets\n    while (input.charCodeAt(i) === codeClosingBrace || input.charCodeAt(i) === codeClosingBracket) {\n      i++\n      parseWhitespaceAndSkipComments()\n    }\n\n    if (!input.isEnd(i)) {\n      throwUnexpectedCharacter()\n    }\n\n    return false\n  }\n\n  function parseWhitespaceAndSkipComments(): boolean {\n    const start = i\n\n    let changed = parseWhitespace()\n    do {\n      changed = parseComment()\n      if (changed) {\n        changed = parseWhitespace()\n      }\n    } while (changed)\n\n    return i > start\n  }\n\n  function parseWhitespace(): boolean {\n    let whitespace = ''\n    let normal: boolean\n    while (\n      (normal = isWhitespace(input.charCodeAt(i))) ||\n      isSpecialWhitespace(input.charCodeAt(i))\n    ) {\n      if (normal) {\n        whitespace += input.charAt(i)\n      } else {\n        // repair special whitespace\n        whitespace += ' '\n      }\n\n      i++\n    }\n\n    if (whitespace.length > 0) {\n      output.push(whitespace)\n      return true\n    }\n\n    return false\n  }\n\n  function parseComment(): boolean {\n    // find a block comment '/* ... */'\n    if (input.charCodeAt(i) === codeSlash && input.charCodeAt(i + 1) === codeAsterisk) {\n      // repair block comment by skipping it\n      while (!input.isEnd(i) && !atEndOfBlockComment(i)) {\n        i++\n      }\n      i += 2\n\n      return true\n    }\n\n    // find a line comment '// ...'\n    if (input.charCodeAt(i) === codeSlash && input.charCodeAt(i + 1) === codeSlash) {\n      // repair line comment by skipping it\n      while (!input.isEnd(i) && input.charCodeAt(i) !== codeNewline) {\n        i++\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  function parseCharacter(code: number): boolean {\n    if (input.charCodeAt(i) === code) {\n      output.push(input.charAt(i))\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipCharacter(code: number): boolean {\n    if (input.charCodeAt(i) === code) {\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipEscapeCharacter(): boolean {\n    return skipCharacter(codeBackslash)\n  }\n\n  /**\n   * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n   * Repair strings enclosed in single quotes or special quotes\n   * Repair an escaped string\n   *\n   * The function can run in two stages:\n   * - First, it assumes the string has a valid end quote\n   * - If it turns out that the string does not have a valid end quote followed\n   *   by a delimiter (which should be the case), the function runs again in a\n   *   more conservative way, stopping the string at the first next delimiter\n   *   and fixing the string by inserting a quote there.\n   */\n  function parseString(stopAtDelimiter = false): boolean {\n    // we may need to revert\n    const iBefore = i\n    const oBefore = output.length()\n\n    let skipEscapeChars = input.charCodeAt(i) === codeBackslash\n    if (skipEscapeChars) {\n      // repair: remove the first escape character\n      i++\n      skipEscapeChars = true\n    }\n\n    if (isQuote(input.charCodeAt(i))) {\n      // double quotes are correct JSON,\n      // single quotes come from JavaScript for example, we assume it will have a correct single end quote too\n      // otherwise, we will match any double-quote-like start with a double-quote-like end,\n      // or any single-quote-like start with a single-quote-like end\n      const isEndQuote = isDoubleQuote(input.charCodeAt(i))\n        ? isDoubleQuote\n        : isSingleQuote(input.charCodeAt(i))\n          ? isSingleQuote // eslint-disable-line indent\n          : isSingleQuoteLike(input.charCodeAt(i)) // eslint-disable-line indent\n            ? isSingleQuoteLike // eslint-disable-line indent\n            : isDoubleQuoteLike // eslint-disable-line indent\n\n      output.push('\"')\n      i++\n\n      const isEndOfString = stopAtDelimiter\n        ? (i: number) => isDelimiter(input.charAt(i))\n        : (i: number) => isEndQuote(input.charCodeAt(i))\n\n      while (!input.isEnd(i) && !isEndOfString(i)) {\n        if (input.charCodeAt(i) === codeBackslash) {\n          const char = input.charAt(i + 1)\n          const escapeChar = escapeCharacters[char]\n          if (escapeChar !== undefined) {\n            output.push(input.substring(i, i + 2))\n            i += 2\n          } else if (char === 'u') {\n            let j = 2\n            while (j < 6 && isHex(input.charCodeAt(i + j))) {\n              j++\n            }\n\n            if (j === 6) {\n              output.push(input.substring(i, i + 6))\n              i += 6\n            } else if (input.isEnd(i + j)) {\n              // repair invalid or truncated unicode char at the end of the text\n              // by removing the unicode char and ending the string here\n              i += j\n            } else {\n              throwInvalidUnicodeCharacter()\n            }\n          } else {\n            // repair invalid escape character: remove it\n            output.push(char)\n            i += 2\n          }\n        } else {\n          const char = input.charAt(i)\n          const code = char.charCodeAt(0)\n\n          if (code === codeDoubleQuote && input.charCodeAt(i - 1) !== codeBackslash) {\n            // repair unescaped double quote\n            output.push('\\\\' + char)\n            i++\n          } else if (isControlCharacter(code)) {\n            // unescaped control character\n            output.push(controlCharacters[char])\n            i++\n          } else {\n            if (!isValidStringCharacter(code)) {\n              throwInvalidCharacter(char)\n            }\n            output.push(char)\n            i++\n          }\n        }\n\n        if (skipEscapeChars) {\n          // repair: skipped escape character (nothing to do)\n          skipEscapeCharacter()\n        }\n      }\n\n      const hasEndQuote = isQuote(input.charCodeAt(i))\n      if (hasEndQuote) {\n        output.push('\"')\n        i++\n      } else {\n        // repair missing quote\n        output.insertBeforeLastWhitespace('\"')\n      }\n\n      parseWhitespaceAndSkipComments()\n\n      // See whether we have:\n      // (a) An end quote which is not followed by a valid delimiter\n      // (b) No end quote and reached the end of the input\n      // If so, revert parsing this string and try again, running in a more\n      // conservative mode, stopping at the first next delimiter\n      const isAtEnd = input.isEnd(i)\n      const nextIsDelimiter = isDelimiter(input.charAt(i))\n      if (\n        !stopAtDelimiter &&\n        ((hasEndQuote && !isAtEnd && !nextIsDelimiter) || (!hasEndQuote && isAtEnd))\n      ) {\n        i = iBefore\n        output.remove(oBefore)\n        return parseString(true)\n      }\n\n      parseConcatenatedString()\n\n      return stack.update(Caret.afterValue)\n    }\n\n    return false\n  }\n\n  /**\n   * Repair concatenated strings like \"hello\" + \"world\", change this into \"helloworld\"\n   */\n  function parseConcatenatedString(): boolean {\n    let parsed = false\n\n    parseWhitespaceAndSkipComments()\n    while (input.charCodeAt(i) === codePlus) {\n      parsed = true\n      i++\n      parseWhitespaceAndSkipComments()\n\n      // repair: remove the end quote of the first string\n      output.stripLastOccurrence('\"', true)\n      const start = output.length()\n      const parsedStr = parseString()\n      if (parsedStr) {\n        // repair: remove the start quote of the second string\n        output.remove(start, start + 1)\n      } else {\n        // repair: remove the + because it is not followed by a string\n        output.insertBeforeLastWhitespace('\"')\n      }\n    }\n\n    return parsed\n  }\n\n  /**\n   * Parse a number like 2.4 or 2.4e6\n   */\n  function parseNumber(): boolean {\n    const start = i\n    if (input.charCodeAt(i) === codeMinus) {\n      i++\n      if (expectDigitOrRepair(start)) {\n        return stack.update(Caret.afterValue)\n      }\n    }\n\n    // Note that in JSON leading zeros like \"00789\" are not allowed.\n    // We will allow all leading zeros here though and at the end of parseNumber\n    // check against trailing zeros and repair that if needed.\n    // Leading zeros can have meaning, so we should not clear them.\n    while (isDigit(input.charCodeAt(i))) {\n      i++\n    }\n\n    if (input.charCodeAt(i) === codeDot) {\n      i++\n      if (expectDigitOrRepair(start)) {\n        return stack.update(Caret.afterValue)\n      }\n      while (isDigit(input.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (input.charCodeAt(i) === codeLowercaseE || input.charCodeAt(i) === codeUppercaseE) {\n      i++\n      if (input.charCodeAt(i) === codeMinus || input.charCodeAt(i) === codePlus) {\n        i++\n      }\n      if (expectDigitOrRepair(start)) {\n        return stack.update(Caret.afterValue)\n      }\n      while (isDigit(input.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (i > start) {\n      // repair a number with leading zeros like \"00789\"\n      const num = input.substring(start, i)\n      const hasInvalidLeadingZero = /^0\\d/.test(num)\n\n      output.push(hasInvalidLeadingZero ? `\"${num}\"` : num)\n      return stack.update(Caret.afterValue)\n    }\n\n    return false\n  }\n\n  /**\n   * Parse keywords true, false, null\n   * Repair Python keywords True, False, None\n   */\n  function parseKeywords(): boolean {\n    return (\n      parseKeyword('true', 'true') ||\n      parseKeyword('false', 'false') ||\n      parseKeyword('null', 'null') ||\n      // repair Python keywords True, False, None\n      parseKeyword('True', 'true') ||\n      parseKeyword('False', 'false') ||\n      parseKeyword('None', 'null')\n    )\n  }\n\n  function parseKeyword(name: string, value: string): boolean {\n    if (input.substring(i, i + name.length) === name) {\n      output.push(value)\n      i += name.length\n      return stack.update(Caret.afterValue)\n    }\n\n    return false\n  }\n\n  function parseUnquotedKey(): boolean {\n    let end = findNextDelimiter()\n\n    if (end !== null) {\n      // first, go back to prevent getting trailing whitespaces in the string\n      while (isWhitespace(input.charCodeAt(end - 1)) && end > i) {\n        end--\n      }\n\n      const symbol = input.substring(i, end)\n      output.push(JSON.stringify(symbol))\n      i = end\n\n      if (input.charCodeAt(i) === codeDoubleQuote) {\n        // we had a missing start quote, but now we encountered the end quote, so we can skip that one\n        i++\n      }\n\n      return stack.update(Caret.afterValue) // we do not have a state Caret.afterKey, therefore we use afterValue here\n    }\n\n    return false\n  }\n\n  function findNextDelimiter(): number | null {\n    // note that the symbol can end with whitespaces: we stop at the next delimiter\n    let j = i\n    while (!input.isEnd(j) && !isDelimiter(input.charAt(j))) {\n      j++\n    }\n\n    return j > i ? j : null\n  }\n\n  function expectDigit(start: number) {\n    if (!isDigit(input.charCodeAt(i))) {\n      const numSoFar = input.substring(start, i)\n      throw new JSONRepairError(`Invalid number '${numSoFar}', expecting a digit ${got()}`, i)\n    }\n  }\n\n  function expectDigitOrRepair(start: number) {\n    if (input.isEnd(i)) {\n      // repair numbers cut off at the end\n      // this will only be called when we end after a '.', '-', or 'e' and does not\n      // change the number more than it needs to make it valid JSON\n      output.push(input.substring(start, i) + '0')\n      return true\n    } else {\n      expectDigit(start)\n      return false\n    }\n  }\n\n  function throwInvalidCharacter(char: string) {\n    throw new JSONRepairError('Invalid character ' + JSON.stringify(char), i)\n  }\n\n  function throwUnexpectedCharacter() {\n    throw new JSONRepairError('Unexpected character ' + JSON.stringify(input.charAt(i)), i)\n  }\n\n  function throwUnexpectedEnd() {\n    throw new JSONRepairError('Unexpected end of json string', i)\n  }\n\n  function throwObjectKeyExpected() {\n    throw new JSONRepairError('Object key expected', i)\n  }\n\n  function throwColonExpected() {\n    throw new JSONRepairError('Colon expected', i)\n  }\n\n  function throwInvalidUnicodeCharacter() {\n    const chars = input.substring(i, i + 6)\n    throw new JSONRepairError(`Invalid unicode character \"${chars}\"`, i)\n  }\n\n  function got(): string {\n    const char = input.charAt(i)\n    return char ? `but got '${char}'` : 'but reached end of input'\n  }\n\n  function atEndOfBlockComment(i: number) {\n    return input.charAt(i) === '*' && input.charAt(i + 1) === '/'\n  }\n\n  return {\n    transform,\n    flush\n  }\n}\n"],"mappings":"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"}